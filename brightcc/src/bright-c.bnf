#!emitnone
#!emit declaration

_ ::= ([#x20] | [#x0A] | [#x0D] | [#xB] | [#x9] | '/*' (. - '*/')* '*/' | '//' (. - ([#0x0A] | [#0x0D]))*)+

id             ::= [A-Za-z_][A-Za-z0-9_]*

hex_literal    ::= '0x' [0-9a-fA-F]+
oct_literal    ::= '0o' [0-7]+
bin_literal    ::= '0b' [0-1]+
int_literal    ::= [0-9]+ | '0' [0-7]+
float_literal  ::= [0-9]* '.' [0-9]+ | [0-9]+ '.' [0-9]*
string_literal ::= '"' ((. - '"') | '\"')* '"'

literal  ::= <float_literal> | <hex_literal> | <oct_literal> | <bin_literal> | <int_literal> | <string_literal>

primary_expression ::= <id> | <literal> | '(' <_>? <expression> <_>? ')'

expression_list ::= <expression> (<_>? ',' <_>? <expression>)*

fncall_expr    ::= <postfix_expression> <_>? '(' <_>? <expression_list>? <_>? ')'
index_expr     ::= <postfix_expression> <_>? '[' <_>? <expression_list>? <_>? ']'
subscript_expr ::= <postfix_expression> <_>? ('.' | '->') <_>? <id>
incr_expr      ::= <postfix_expression> <_>? ('++' | '--')

postfix_expression ::= <fncall_expr> | <index_expr> | <subscript_expr> | <incr_expr> | <primary_expression>

unary_expression ::= ( '++' | '--' | '+' | '-' | '&' | '~' | '!' | '*' ) <_>? <postfix_expression> | <postfix_expression>

cast ::= '(' <_>? <type> <_>? ')' <_>? <unary_expression>
cast_expression ::= <cast> | <unary_expression>

multiplicative_operator ::= '*' | '/' | '%'
multiplicative_expression ::= <multiplicative_expression> <_>? <multiplicative_operator> <_>? <cast_expression> | <cast_expression>

additive_operator ::= '+' | '-'
additive_expression       ::= <additive_expression> <_>? <additive_operator> <_>? <multiplicative_expression> | <multiplicative_expression>


shift_expression        ::= (<additive_expression>     <_>? ("<<" | ">>") <_>?)*             <additive_expression>
relational_expression   ::= (<shift_expression>        <_>? (">=" | ">" | "<=" | "<") <_>?)* <shift_expression>
equality_expression     ::= (<relational_expression>   <_>? ("==" | "!=") <_>?)*             <relational_expression>
and_expression          ::= (<equality_expression>     <_>? ("&" - "&&" - "&=") <_>?)*                       <equality_expression>
exclusive_or_expression ::= (<and_expression>          <_>? ("^" - "^=") <_>?)*                       <and_expression>
inclusive_or_expression ::= (<exclusive_or_expression> <_>? ("|" - "||" - "|=") <_>?)*                       <exclusive_or_expression>
logical_and_expression  ::= (<inclusive_or_expression> <_>? "&&" <_>?)*                      <inclusive_or_expression>
logical_or_expression   ::= (<logical_and_expression>  <_>? "||" <_>?)*                      <logical_and_expression>

# CONTINUE HERE
conditional_expression ::= <logical_or_expression>

assignment_expression ::= <unary_expression> <_>? <assignment_operator> <_>? <assignment_expression> | <conditional_expression>

assignment_operator ::= '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^=' | '='

const_expression ::= <conditional_expression>

expression  ::= (<assignment_expression> <_>? ',' <_>?)* <assignment_expression>

storage_specifier ::= 'export' | 'static' | 'extern' | 'async'

type_qualifier ::= 'volatile' | 'const' | 'restrict' | 'atomic'

pointer_type ::= <qualified_type> <_>? '*'

struct_member_name ::= ('*' <_>?)* <id> <_>? <array_size_specifier>?
struct_member_decl ::= <type> <_>? <struct_member_name> ( <_>? ',' <_>? <struct_member_name>)* <_>? ';'

struct_type ::= 'struct' <_>? <id>? (<_>? '{' <_>? (<struct_member_decl> <_>?)* '}')?

qualified_type ::= ( <struct_type> | (<pointer_type> | <id>)) (<_> <type_qualifier>)*

type ::= (<type_qualifier> <_>?)* <qualified_type>

expr_statement     ::= <expression>? <_>? ';'
while_statement    ::= 'while'  <_>? '(' <_>? <expression> <_>? ')' <_>? <statement>
switch_statement   ::= 'switch' <_>? '(' <_>? <expression> <_>? ')' <_>? <statement>
if_statement       ::= 'if'     <_>? '(' <_>? <expression> <_>? ')' <_>? <statement> (<_>? 'else' <_>? <statement>)?
for_statement      ::= 'for'    <_>? '(' <_>? <expr_statement> <_>? <expr_statement> (<_>? <expression>)? <_>? ')' <_>? <statement>
return_statement   ::= 'return' (<_>? <expression>)? ';'
labelled_statement ::= 'default' <_>? ':' | 'case' <_> <const_expression> <_>? ':'

statement ::= <declaration> | <block> | <while_statement> | <if_statement> | <for_statement> | <return_statement> | <switch_statement> | <expr_statement> | <labelled_statement>

block ::= '{' <_>? (<statement> <_>?)* '}'

array_size_specifier ::= '[' <_>? <const_expression> <_>? ']'

designation ::= (('[' <_>? <const_expression> <_>? ']' | '.'? <_>? <id>) <_>?)+ '='

initializer ::= <designation>? <_>? <const_expression>

initializer_list ::= '{' <_>? <initializer> ( <_>? (',' | ';') <_>? <initializer> )* <_>? (',' | ';')? <_>? '}'

variable_init ::= <const_expression> | <initializer_list>

variable_declaration_init ::= <id> <array_size_specifier>? (<_>? '=' <_>? <variable_init>)?

variable_declaration ::= <_>? (<storage_specifier> <_>)* <type> <_>? <variable_declaration_init> (<_>? ',' <_>? <variable_declaration_init>)* <_>? ';'

parameter ::= <type> <_>? <id>?

parameter_list ::= <_>? <parameter> <_>? (',' <_>? <parameter>)* (<_>? ',' <_>? '...')?

function_attribute ::= (<_>? ("__cdecl" | "__stdcall") <_>?)+

function_declaration ::= <_>? (<storage_specifier> <_>)* <type> <_>? <function_attribute>? <_>? <id> <_>? '(' <_>? <parameter_list>? <_>? ')' <_>? ( ';' | <block> )

enum_item ::= <id> <_>? '=' <_>? <const_expression> | <id>

enum_items ::= <enum_item> ( <_>? ',' <_>? <enum_item> )* <_>? ','?

enum_declaration ::= 'enum' <_> <id> <_>? '{' <_>? <enum_items> <_>? '}' <_>? ';'

struct_declaration ::= <struct_type> ';'

typedef_declaration ::= 'typedef' <_> <type> <_>? <id> <_>? ';'


declaration ::= <typedef_declaration> | <struct_declaration> | <variable_declaration> | <function_declaration> | <enum_declaration>








preprocessor ::= '#' (. - ([#0x0A] | [#0x0D]))*

# This "must" be last
translation_unit ::= (<declaration> | <preprocessor> | <_>?)*
